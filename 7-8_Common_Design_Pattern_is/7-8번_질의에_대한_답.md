What design patterns are commonly used in iOS apps?, What are the design patterns besides common Cocoa patterns that you know of?
=================================================================================================================================

"iOS 앱에서 흔히 사용되는 디자인 패턴은 무엇입니까?" 이 질문은 어쩌면 초급 개발자를 제외한 모든 등급의 개발자들에게 물어보는 질문일 것입니다. iOS 개발자로서 iOS 플랫폼에서 흔히 사용되는 기술, 구조, 디자인 패턴에 익숙해야 합니다.

iOS 애플리케이션 개발시 흔하게 사용되는 전형적인 패턴들은 Cocoa, Cocoa Touch, Objective-C, Swift 문서에 잘 나타나 있습니다. 이러한 패턴은 모든 iOS 개발자들이 익혀야 합니다. 문서에 나타나는 패턴은 MVC, Singlton, Delegate, Observer 등이 있습니다.

간혹 MVC 만 언급하는 사람들이 있는데... 그런 모든 iOS 개발자들이 알고 있는 내용을 대답으로 듣고싶어하는 인터뷰어는 없습니다... 이 질문은 iOS 전반에 대해 얼마나 잘 알고 있는지 확인하기 위한 질문입니다.

* * *


## MVC
- Cocoa 의 근간이 되는 핵심 패턴중 하나입니다.  화면 설계를 위해 파일 생성시 기본으로 제공되는 패턴이죠. 오브젝트를 일반적인 역할에 따라 분류(model, view, controller)하고, 그 역할에 따라 코드를 완전히 분리하도록 도와줍니다.
	- Model: data 와 data 를 제어할수 있는 코드를 포함합니다.
	- View: model 의 시각적 표현을 담당하고, 사용자와 애플리케이션이 소통할 수 있도록 해주는 코드를 포함합니다.
	- Controller: 모든 일을 제어하는 중개자 역할을 합니다. model 의 data 에 접근하여 view 를 표시하고, 이벤트를 수신하고, 필요에 따라 data 를 조작합니다.

- 각 개체가 자신이 해야할 작업만 수행할 수 있도록 해야합니다. 가능하면 model 에서 수행해야 할 기능을 view 나 controller 에 구현하지 마세요!

- 가능한 한 프로젝트 내에 Model, View, Controller 그룹을 생성하여 그 안에 파일을 생성하는게 좋습니다.

![MVC in Cocoa](https://developer.apple.com/library/content/documentation/General/Conceptual/DevPedia-CocoaCore/Art/model_view_controller_2x.png)

- 자매품으로 MVP(Model-View-Presenter: MVC 에서의 M-V 간 의존성을 줄이기 위해..), MVVM(Model-View-ViewModel: MVP 에서 V-P 간 의존성 조차 줄이기 위해.. ) 등이 있습니다.
> [MVC vs MVP vs MVVM 관련 링크](http://blog.naver.com/PostView.nhn?blogId=itperson&logNo=220840607398&parentCategoryNo=&categoryNo=92&viewDate=&isShowPopularPosts=true&from=search)

* * *


## Singleton
- 프로젝트에서 특정 기능에 맵핑된 단 하나의 연결점이 필요한 경우 사용합니다. 예를 들어, Network 통신시 하나의 연결점을 두고, 그 안에서 serial 하게 통신을 연결 시킨다거나 하는 작업 등에 유용합니다. 다만 애플리케이션이 종료되기 전까지 메모리에 상주하기 때문에 불필요하게 메모리를 잡아먹지 않도록 잘 관리해야 합니다. 

- 앞에서 언급한 기기의 제약이 있는 경우가 아니고 side effect 가 발생하지 않게 함수를 설계한다면 꼭 Singleton 패턴을 사용하지 않고 static 한 순수한 함수들을 모아 놓은 Utility type 을 생성하는 것이 대안이 될 수 있습니다.(가급적 무의미한 의존성 주입은 자제해야죠)

``` swift
class Singleton {
	// static 변수로 선언하면 lazy 하게 동작합니다. 그러므로 실제 호출이 있기 전에 메모리에 올라가지 않습니다.
	// let 은 기본적으로 thread-safe 하므로 dispatch_once_t 같은 처리를 하지 않아도 됩니다.
	static let shared = Singleton()
	/*
	만약 초기 설정이 필요하다면 closure 로 구현하면 됩니다.
	static let shared: Singleton = {
		let _shared = Singleton()
		_shared.property = 100
		// do something more...
		return _shared
		}()
	*/
	var property: Int = 0
	private init(){}
}
```

* * *


## Facade
- 복잡한 개체들에 대한 하나의 인터페이스를 제공해야하는 경우 사용합니다. 아래는 간단한 예입니다.

``` swift
struct OrderPart {
	func order(name: String, count: Int) -> Receipt {}
}
struct CookingPart {
	func cook(name: String, count: Int) -> Food {}
}
struct ServePart {
	func serve(food: Food, count: Int, tableNo: Int) -> Service {}
}

// 식당에서 주문시 고객은 음식만 주문하면 됩니다.
// 나머지는 식당이 알아서 진행하고 음식과 영수증을 고객에게 전달하면 되는거죠
struct Restaurant {
	private(set) var manager = OrderPart()
	private(set) var shef = CookingPart()
	private(set) var waiter = ServePart()

	func orderFood(name: String, count: Int, tableNo: Int) -> (Service, Receipt) {
		let receipt = manager.order(name: name, count: count)
		let food = shef.cook(name: name, count: count)
		let service = waiter.serve(food: food, count: count, tableNo: tableNo)
		return (service, receipt)
	}
}

let restaurant = Restaurant()
let result = restuarant.orderFood(name: "Burger", count: 1, tableNo: 5)
print("\(result.0), \(result.1)") // "free smile", ["food": "Burger", "count": "1", "total": "6.7"]
```

* * *


## Decorator
- 어떤 개체의 원래 특성을 바꾸지 않고 동적으로 역할 및 책임을 추가하는 패턴입니다. 

- Objective-C 의 category, Swift 의 extension 은 기능의 수평 확장으로 서브 클래스를 추가하지 않고 새로운 행동을 추가할 수 있다는 점이 유사합니다. 하지만 category, extension 은 컴파일 타임의 정적 바인딩이고, 확장되는 클래스 인스턴스를 캡슐화하지 않는 등의 차이점이 있습니다. 그래도 swift 의 extension 은 서브 클래스를 추가하지 않고, 구현하기 쉬우며, 가볍다는 장점이 있죠. (더 멋진건 원본 코드가 없어도 기능을 확장할 수 있다는 것입니다. 즉, UIView, UIImage 등에도 커스텀 함수를 추가하여 기능을 확장할 수 있다는 뜻입니다.)

- 클래스의 정의가 감추어져 있거나 서브 클래스를 생성할 수 없는 경우, 클래스의 기능 확장을 위해 많은 수의 서브 클래스가 필요한 경우 사용하면 유용합니다.

- 객체 지향 설계 원칙 중 하나인 Open-Closed Principle 에 부합합니다.(확장에는 열려있고, 수정에는 닫혀있는...)

```swift
protocol Food {
    func getStyle() -> FoodStyle
    func getIngredients() -> String
    func getCost() -> Float
}

enum FoodStyle: String {
    case raw, fried, boiled, steamed
}

class Chicken: Food {
    private let costPrice: Float = 1.0
    private var style: FoodStyle

    init(style: FoodStyle) {}

    func getStyle() -> FoodStyle {}
    func getIngredients() -> String {}
    func getCost() -> Float {}

    private func evaluateCost(_ style: FoodStyle) -> Float {}
}

class ChickenDecorator: Food {
    let decorator: Food
    let ingredientsSeparator = ", "
    
    required init(_ decorator: Food) {}
    
    func getStyle() -> FoodStyle {
        return decorator.getStyle()
    }
    func getIngredients() -> String {}
    func getCost() -> Float {}
}

class SoySauceChicken: ChickenDecorator {
    required init(_ decorator: Food) {
        super.init(decorator)
    }
    
    override func getStyle() -> FoodStyle {}
    override func getIngredients() -> String {
        return super.getIngredients() + ingredientsSeparator + "Soy Sauce"
    }
    override func getCost() -> Float {
        return super.getCost() * 1.15
    }
}

class SpicyGalicChicken: ChickenDecorator {
    required init(_ decorator: Food) {}
    
    override func getStyle() -> FoodStyle {}
    override func getIngredients() -> String {}
    override func getCost() -> Float {}
}

func testDecorator() {
    let chicken = Chicken(style: .fried)
    print("chicken - cost: \(chicken.getCost()), ingredients: \(chicken.getIngredients())")
    let soySauceChicken = SoySauceChicken(chicken)
    print("soySauceChicken - cost: \(soySauceChicken.getCost()), ingredients: \(soySauceChicken.getIngredients())")
    let spicyGalicChicken = SpicyGalicChicken(chicken)
    print("spicyGalicChicken - cost: \(spicyGalicChicken.getCost()), ingredients: \(spicyGalicChicken.getIngredients())")
}
```

[샘플 코드 링크](ChickenSeller.swift)

* * *


## Delegation
- delegation 도 decorator 중 하나입니다. UIKit 에서 매우 빈번하게 사용되고 있죠. UITableView, UICollectionView, UITextView, UIWebView... 등 모두 delegation 을 이용해 서브 클래스를 추가하지 않고 기능을 확장합니다. UITableView 를 예로 들어보면 UITableView 는 UITableViewDelegate 를 통해 controller 와 통신을 하여 cell 선택시에 대한 전반적인 작업을 수행합니다. UITableViewDataSource 를 이용해서는 tableView 의 section, row 에 표시되어야 할 model 들에 접근하여 화면을 구성합니다. 

- 아래는 delegation 을 이용한 샘플입니다. 전체적인 구조가 매끄럽지는 않지만 샘플에서처럼 커피숍만 만들거나, 쇼핑몰 혹은 특정 건물 내에 커피숍을 추가로 개점할 때 커피숍을 위한 클래스를 추가하지 않고 해당 건물에 CoffeeCenter 를 설치하고 DripCoffeeDelegate, DripCoffeeDataSource 를 준수하도록 구현하면 됩니다. 생각보다 시간이 오래 걸려 진한 커피를 희석시키는 dilute(::) 메서드는 구현하지 못했습니다. 직접 구현해 보세요 ㅋㅋㅋ

```swift
/// 커피 추출을 위한 프로토콜
protocol DripCoffeeDelegate: class {
    /// 커피 가루를 선택해 커피를 추출합니다.
    func drip(_ powder: CoffeePowder) -> Coffee
    /// 커피가 진하면 물을 추가해 희석할 수 있습니다.
    func dilute(_ coffee: Coffee, amountOfWater: Float) -> Coffee?
}

/// 커피 추출 준비를 위한 프로토콜
protocol DripCoffeeDataSource: class {
    /// 커피 가루의 수
    func numberOfCoffeePowders() -> Int
    /// 커피 추출을 위한 도구
    func equipments() -> [String]
    /// 커피 가루 생성
    func coffeePowder(index: Int) -> CoffeePowder
    /// 이미 있는 가루에서 amount 만큼 사용
    func coffeePowder(index: Int, amount: Float) -> CoffeePowder
    /// DripCoffeeDelegate 의 drip(_:) 에서 사용되는 커피 생성용 메서드
    func coffee(index: Int) -> Coffee?
    /// DripCoffeeDelegate 의 dilute(_::) 에서 사용되는 커피 희석용 메서드
    func coffee(index: Int, size: Coffee.Size) -> Coffee?
}

/// 커피 가루
class CoffeePowder {
    /// 로스팅 정도
    enum RoastLevel: String {
        case everGreen, lightGreen, gray, brown, darkBrown
    }
    
    var name: String
    var countryOfOrigin: String
    var roastLevel: RoastLevel
    var amount: Float
    
    init(name: String, countryOfOrigin: String, roastLevel: RoastLevel, amount: Float) {}
    
    /// 커피 추출시 컵 사이즈에 맞춰 가루 용량을 줄임
    func use(size: Coffee.Size) -> CoffeePowder {}
    /// 커피 추출시 사용된 용량에 맞춰 가루 용량을 줄임
    @discardableResult
    func use(amount: Float) -> CoffeePowder {}
    /// 모자란 커피 가루 추가
    func add(amount: Float) -> CoffeePowder {}
}

extension CoffeePowder: CustomStringConvertible {
    var description: String {
        return "\n name: \(name), countryOfOrigin: \(countryOfOrigin), roastLevel: \(roastLevel.rawValue), amount: \(amount)"
    }
}


/// 커피
class Coffee {
    /// 커피 컵 사이즈
    enum Size: String {
        case short, tall, large, grande
    }
    
    var powder: CoffeePowder
    var size: Size
    var volume: Float
    var iced: Bool
    var isDiluted: Bool = false
    
    init(powder: CoffeePowder, size: Size, iced: Bool) {}
}

extension Coffee: CustomStringConvertible {
    var description: String {
        return "\n name: \(powder.name), size: \(size.rawValue), volume: \(volume), iced: \(iced), isDiluted: \(isDiluted)"
    }
}


/// 커피 가루 생성을 위한 팩토리
class CoffeeFactory {
    /// 아래의 3가지 원두만 취급함
    static let coffees = ["Brazil Santos": CoffeePowder.RoastLevel.brown,
                          "Kenya AA": CoffeePowder.RoastLevel.darkBrown,
                          "Costa Rica": CoffeePowder.RoastLevel.brown]
    /// 커피 가루 만들기
    private static func roasting(_ name: String, level: CoffeePowder.RoastLevel) -> CoffeePowder? {}
    /// 원두를 선택하면 roasting(_::) 메서드를 이용해 커피 가루를 만들어 반환
    static func coffeePowder(_ name: String) -> CoffeePowder? {}
    /// 커피 가루로 커피 한잔 생성
    static func coffee(_ powder: CoffeePowder, size: Coffee.Size, iced: Bool) -> Coffee {}
}


/// DripCoffeeDelegate, DripCoffeeDataSource 를 이용해 커피 추출을 위한 작업을 진행하는 곳
class CoffeeCenter {
    /// 커피 컵 사이즈와 커피 가루, 커피 용량 변환을 위한 utility
    struct UnitConverter {
        static func coffeeSize(of amount: Float) -> Coffee.Size {}
        static func coffeeAmount(of size: Coffee.Size) -> Float {}
        static func coffeeVolume(of size: Coffee.Size) -> Float {}
    }
    
    weak var delegate: DripCoffeeDelegate?
    weak var dataSource: DripCoffeeDataSource?
    private var equipments:[String]?
    private let minimumCoffeePowderCapacity: Float = 100.0
    private let reloadCoffeePowderCapacity: Float = 600.0

    /// 커피 추출 준비
    func ready() {}
    /// 커피 추출
    func makeCoffee(powder: CoffeePowder, size: Coffee.Size, iced: Bool) -> Coffee? {}
    /// 커피 보충
    func reloadCoffeePowdersIfNeeded(_ coffeePowders: inout [CoffeePowder]) {}
    
}

/// 커피숍
class CoffeeShop {
    private var coffeePowders = [CoffeePowder]()
    private weak var center: CoffeeCenter?
    private var orderedInfo: (size: Coffee.Size, iced: Bool)?

    init(_ coffeeCenter: CoffeeCenter) {}
    
    /// 커피 가루 목록
    func showCoffeeList() -> [CoffeePowder] {}
    /// 커피 주문
    func order(_ powder: CoffeePowder, size: Coffee.Size, iced: Bool) -> Coffee? {}

    /// 커피 가루 추가
    private func addCoffee(_ name: String) {}
    /// 커피 가루 갯수 확인    
    private func checkCount(index: Int) {}
    /// 커피 센터 존재 확인
    private func checkCenter(fn:(CoffeeCenter) -> Void) {}
    /// 커피 추출시 가루 사용
    private func usePowder(_ powderIndex: Int, amount: Float) -> CoffeePowder {}
    private func usePowder(_ powder: CoffeePowder, amount: Float) {}
}

extension CoffeeShop: DripCoffeeDelegate {
    func drip(_ powder: CoffeePowder) -> Coffee {}
    func dilute(_ coffee: Coffee, amountOfWater: Float) -> Coffee? {}
}

extension CoffeeShop: DripCoffeeDataSource {
    func numberOfCoffeePowders() -> Int {}
    ...
    func coffee(index: Int, size: Coffee.Size) -> Coffee? {}
}


func testCoffeeShop() {
    print()
    let coffeeCenter = CoffeeCenter()
    let coffeeShop = CoffeeShop(coffeeCenter)
    var menu = coffeeShop.showCoffeeList()
    print()
    print("menu: \(menu)")
    if let dripCoffee = coffeeShop.order(menu[0], size: .tall, iced: true) {
        print(dripCoffee)
    }
    for _ in 0...6 {
        if let dripCoffee = coffeeShop.order(menu[1], size: .grande, iced: true) {
            print(dripCoffee)
        }
    }
    print()
    menu = coffeeShop.showCoffeeList()
    print("menu: \(menu)")
    print()
}
```

[샘플 코드 링크](CoffeeShop.swift)

* * *


## Factory Method
* * *


## Adaptor
* * *


## Command
* * *


## Template
* * *


