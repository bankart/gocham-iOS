What do you know about singletons? Where would you use one and where would you not?
===================================================================================

Singleton is a common design pattern used in many OOP languages, and Cocoa considers it one of the “Cocoa Core Competencies.” This question comes up from time to time on interviews to either gauge your experience with singletons or to find out if you have a background in something other than just iOS.

Expected answer:

Singleton is a class that returns only one and the same instance no matter how many times you request it.

Singletons are sometimes considered to be an anti-pattern. There are multiple disadvantages to using singletons. The two main ones are global state/statefulness and object life cycle and dependency injection. When you have only one instance of something, it is very tempting to reference and use it everywhere directly instead of injecting it into your objects. That leads to unnecessary coupling of concrete implementation in your code instead of interface abstraction. 
Another malicious side effect of “convenient” singletons is global state. Quite often singletons enable global state sharing and play the role of a “public bag” that every object uses to store some state. That leads to unpredictable results and bugs and crashes when this uncontrolled state gets overridden or removed by someone.


https://cocoacasts.com/are-singletons-bad/

- 싱글톤 클래스는 몇 번을 요청해도 항상 동일한 객체를 반환합니다. 즉 싱글톤 객체란 애플리케이션 전반에 걸쳐 단 하나만 존재하는 클래스의 인스턴스를 말합니다. 코코아 프레임워크에서는 싱글톤을 매우 중요하게 생각하는데요. 우선 우리가 프로젝트 생성 후 가장 먼저 만나게되는 UIApplication 자체가 애플리케이션에 단 하나만 존재하는 싱글톤 객체이죠 소오~름.(그 외에 NotificationCenter.default, UserDefaults.standard, FileManager.default 등이 있습니다.)

- 현재 애플에서 지원을 중단한 듯한 "Cocoa Fundermental Guides" 에서는 싱글톤 객체를 반환하는 팩토리 메서드의 명명법은 "shared" + ClassType 라고 합니다만... swift 의 API 를 확인해보면 UIApplication 같은 경우에는 UIApplication.shared 라고 class computed var 로 선언되어 있습니다. 

- 싱글톤은 간단하게 구현(Objective-C 보다 훨씬 더 간결하게 구현할 수 있게 되었습니다.)해서 쉽게 사용할 수 있지만 anti-pattern 이라는 비난을 받기도 하죠. 그 이유는 단 하나의 객체를 이곳 저곳에서 직접적으로 접근하여 사용하다보니 특정 값에 변동이 생긴다면 예상하지 못한 버그가 발생할 수도 있고, 그로 인해 의도치 않게 해당 값 또는 상태에 의존하게 되기 때문입니다. 그렇기 때문에 애플은 싱글톤 객체를 일종의 컨트롤 센터로 만들어서 싱글톤 클래스의 서비스를 관리하도록 구현하였습니다.

``` swift
class MySingleton {
	static let shared = MySingleton()
	var routeOfViews = [String]()
	private init() {}
}

// 각 화면에 진입할 때 마다 routeOfViews 에 화면 이름을 저장합니다.
MySingleton.shared.routeOfViews.append(String(describing: self).components(separatedBy: ".").last!)
```

- swift 는 전역변수 호출시 lazy 하게 초기화합니다. 즉 호출하는 시점에 초기화가 진행되어 해당 객체를 생성한 후 반환해준다는 거지요.(메모리 관리의 압박이 있는 iOS 를 위한 내부적인 메모리 최적화 방침이 아닐까요? ㅎㅎㅎ). 그리고 thread safe 하게 dispatch_once 로 동작합니다. 거의 집사 수준으로 개발자 편의를 위해 봉사하고 있습니다.

[Singleton is good 관련 참고 영상 링크](https://cocoacasts.com/what-is-a-singleton-and-how-to-create-one-in-swift/)
[Singleton is bad 관련 참고 영상 링크](https://cocoacasts.com/are-singletons-bad/)
[전역 상수 사용시 lazy 처리에 대한 링크](https://outofbedlam.github.io/swift/2016/03/04/Lazy/)
[@noescape 에 대해 잘 설명된 링크](https://krakendev.io/blog/hipster-swift)


- 그외에도 연산 프로퍼티에 클로저를 할당할 시엔(클로저는 함수이므로 일급객체인 함수는 어디에든 할당할 수 있습니다.) 컴파일러가 해당 클로저는 @noescape 속성이 적용됐다라고 판단하여 강한 참조 사이클에 빠지지 않도록 도와주기도 합니다. 참 똑똑한 컴파일러네요. 말 그대로 해당 클로저는 'no escape' 라는 뜻입니다. 내부 연산이 해당 클로저의 범위를 벗어나지 않으므로 self 를 사용하더라도 레퍼런스 카운트의 증감을 생각할 필요가 없습니다. 






