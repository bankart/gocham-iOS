What is an iOS application and where does your code fit into it?
================================================================

* * *
애플리케이션이란?
------------
단순하게 보면 시스템이 메인 쓰레드에 런 루프 하나 생성하는 것. 하지만 시스템은 애플리케이션으로 다양한 이벤트를 전달하고 애플리케이션은 앱 델리게이트를 통해 이벤트에 부합하는 메서드를 호출 또는 local notification 을 사용하여 알려준다. (애플리케이션은 시스템 프레임워크와 커스텀 코드 사이에서 세련되게 동작한다. 시스템 프레임워크는 앱이 실행되는데 기본적인 기반환경을 제공하고, 우리는 제공된 기반환경을 커스터마이징하여 우리가 원하는 모양으로 만들 수 있다.)

* * *
앱의 라이프 사이클
--------------
단순하게 선형적으로 표현하면 아래와 같다.  <br />
(0)not-running ->(inactive)->  <br />
(1: `application(_ willLauchingWithOptions:)`)foreground(inactive) ->  <br />
(2: `application(_ didLauchingWithOptions:)` ~ `applicationDidBecomActive()`)foreground(active) ->(inactive)->  <br />
(3: `applicationWillResignActive()` ~ `applicationDidEnterBackground()`)background ->(inactive)->  <br />
(4)suspended ->  <br />
(5: `applicationWillTerminate(:)`)terminated(not-running)  <br />

1. 상태의 전환시 아주 잠시동안 inactive 상태가 된다.
2. 사용자가 아이콘을 탭하여 앱을 실행시키거나, 다른 앱에 의해 실행되거나, push notification 을 통해 실행될 수 있다. 이를 판단하는 단계가 1~2번 단계이고 `application(_ willFinishLaunchingWithOptions:)` 메서드가 호출된다. options 로 전달된 dictionary 를 보고 앱이 어떤 경로로 실행되었는지 확인할 수 있다. 
3. 1~2번 단계에서는 사용 가능한 Storyboard 로부터 UI 파일을 로드하고, 앱을 구동시키는데 필수적인 오브젝트들에 대한 초기화가 일어난다. 이때 커스텀 오브젝트들도 초기화를 하면 된다. 단, 앱이 빠르게 구동되는게 중요하기 때문에 main thread 에서 동작하는 작업들은 삼가해야 한다. 상태 복원을 지원하는 앱은 여기에서 상태를 복원한다.(시스템은 5초 이내에 이 프로세스가 완료되지 않거나 오동작한다고 판단되면 앱을 종료시킬 수 있다.)
4. 시스템은 3번 단계(background 로 전환시)에서 요구하는 것이 많다.  <br /> 
 - 다른 foreground 에 있는 앱들을 위해 불필요한 메모리는 모두 해제하여 가용메모리를 확보해야 한다.
 - main thread 에서 동작하는 작업들을 모두 정지시켜야 한다.
 - 만약 위의 프로세스 진행중 약간의 시간이 더 필요하다면 `beginBackgroundTask(::)` 를 호출하여 마무리하고, 작업 완료시 꼭 `endBackgroundTask(:)` 를 호출해 시스템이 suspended 상태로 전환할 수 있도록 알려줘야 한다.(가급적 사용하지 않는다.)
 - `applicationDidEnterBackground(:)` 메서드 종료시점에 시스템은 앱간 전환용, 멀티태스킹 화면용 이미지를 캡쳐한다. 만약 background 진입시 사용자 정보 등 민감한 정보가 표시되고 있다면 함수 종료 전 화면을 조작해야 한다. 그러면 조작된 화면이 캡쳐되어 정보의 노출을 방지할 수 있다.
 - 만약 background 작업을 지원하고 싶다면 Info.plist 파일에 UIBackgroundModes 키를 추가해서 suspended 상태로 진입하지 않도록 해야한다. 만약 background 지원을 전혀 하지 않으려면 UIApplicationEixtsOnSuspend 키를 추가해야 한다. 그렇게 하면 background, suspended 상태로 진입하지 않는다.  <br />
5. 4번 단계에서는 기기의 메모리 상황에 따라 시스템에 의해 앱이 종료될 수 있다. 이때 `applicationDidReceiveMemoryWarning(:)`, `vc.didReceiveMemoryWarning()` 이 호출되고, `UIApplicationDidReceiveMemoryWarningNotification` 이 전달된다. 이때 적절히 불필요한 메모리를 제거하는 등 행동을 취해야 한다. 그렇지 않으면 시스템이 앱을 종료시킬 수도 있다. 또는 dispatch source 중 DISPATCH_SOURCE_TYPE_MEMORYPRESSURE 를 이용해 메모리 경고 단계를 체크하여 상태별로 메모리를 관리할 수도 있다. 앱 사용중 push notification 이 들어와서 해당 notification 을 따라 다른 앱으로 이동하거나, 사용자가 멀티태스킹 화면으로 진입한 경우에도 3~4번 단계가 진행된다.
6. 5번 단계는 앱이 종료되기 직전으로 기기가 reboot 중이거나, suspended 상태거나, 멀티태스킹 화면에서 사용자가 명시적으로 앱을 종료시킨 것이라면 `applicationWillTermiate(:)` 메서드는 호출되지 않는다. background 에서 동작중인 경우에만 호출된다. 이 메서드는 사용자 정보나 상태 정보등을 저장하는 동안 기다려주지 않기 때문에 이런 데이터들은 해당 데이터를 제어하는 화면에 사라지는 순간등 적절한 시기에 저장해야한다.


