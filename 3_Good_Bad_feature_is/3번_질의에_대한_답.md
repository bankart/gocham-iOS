What features of Swift do you like or dislike? Why?
===================================================

최근들어 3.2/4 버전 swift 로 업데이트 되면서 이 언어가 iOS 발전의 미래임을 거듭 증명하고 있고, 노련한 개발자들은 swift 언어가 제공하는 특징들에 대해 잘 알고 있어야 한다.

예상답변:
강한 타입 제약과 언어의 함수형 프로그래밍 특징 그리고 무엇이 마음에 들고 무엇이 그렇지 않은지에 대해 이야기할 수 있어야 한다. 정답은 없지만 언어에서 제공하는 특징(제네릭, 프로토콜, 옵셔널 등등)들과 연계하여 대답하길 기대한다. 또 언어에서 좋다고 생각하는 점, 나쁘다고 생각하는 점에 대해 토론할 수 있어야 한다.(ex 난 옵셔널 체인을 선호하지 않는다. 왜냐하면 이건 자연의 섭리를 깨는 행위이다.)
> 대화 주제: protocol, functional programming, generic, optional, struct's map/filter/reduce, enum(indirect)
>  좋은거: protocol, functional programming, generic
>  싫은거: substring, for-in 문, swift abi stability
* * *

## 장점
1. #### 프로토콜 지향 프로그래밍이 가능함

  **[oop 단점]**
 - 일반적인 oop 의 경우 설계시 super 클래스가 요구하는 사항들이 많아져서 sub 클래스에서는 불필요한 property 나 메서드들을 가지고 있어야 한다. 그리고 무조건 super 클래스의 생성자를 호출해야 한다. 이것은 일관된 초기화를 제공할 수도 있지만, 계층이 깊어질 수록 주의를 기울이지 않으면 잘못된 초기화를 야기할 수도 있다. 
 - 하나의 클래스는 하나의 super 클래스만 상속 받을 수 있다.
 - 참조 타입이기 때문에 부주의할 경우 예상하지 못한 결과를 초래할 수 있다.
 - 클래스로만 기능 상속이 가능하다. 값 타입으로는 기능을 상속할 수 없기 때문에 해당 기능을 값 타입들에도 추가해야해서 중복 코드를 발생시킨다.
 
  **[pop 장점]**
 - 각 타입들이 복수의 프로토콜을 채택할 수 있다. 이는 거대한 super 클래스가 아닌 기능별로 세분화된 다수의 프로토콜을 만들 수 있다는 의미이고(기능의 모듈화), 제네릭을 이용한 프로토콜을 확장할 경우 중복 코드가 oop 에 비해 많이 줄어들어 코드가 간결해진다.
 - 프로토콜 확장시 원본 코드가 없어도 기능을 추가할 수 있다. 이는 어떠한 프로토콜도 확장이 가능하다는 의미이다. (super 클래스도 확장을 통해 기능을 추가할 수 있지만 해당 클래스의 sub 클래스들이 모두 추가된 기능을 가지게 된다. 일반적으로 클래스에서의 확장은 특정 클래스에 기능을 추가하는데 사용한다.)
 - 프로토콜은 레퍼런스 타입, 값 타입 모두 적용이 가능하다.

  **[프로토콜 지향 프로그래밍을 하는 이유]**
 - 구조체, 클래스, 열거형 등 구조화된 타입 중 상속은 클래스 타입에서만 가능하다. 클래스는 참조 타입이므로 참조 추적에 비용이 많이 발생한다. 값 타입을 활용하고 싶어도, 상속이 불가하므로 때마다 기능을 다시 구현해야 하지만, 프로토콜 지향 프로그래밍은 그 한계를 없앴다.
 - 기능의 모듈화가 명확해 진다. 클래스는 다중상속을 지원하지 않는다. 하나의 상속체계에서 다른 상속체계에 속해있는 기능을 끌어다 쓸 수 없다는 뜻이다. 그러나 프로토콜 지향 프로그래밍은 기능을 프로토콜이라는 단위로 묶어 표현하고 초기 구현을 해둘 수 있으니 상속이라는 한계점을 탈피할 수 있다.
 * * *  

2. #### 함수형 프로그래밍
    - oop 의 경우 함수 실행시 함수에 전달된 파라미터 외에도 포인터, 레퍼런스 값 등 객체의 상태 값 또는 메모리 참조 값 등이 변경될 수 있으며 함수 내부의 처리에도 영향을 미칠 수 있다. 그러나 함수형 프로그래밍에서는 순수하게 함수에 전달된 파라미터들에 의해서만 결과에 영향을 주므로 상태 값을 갖지 않고 순수하게 함수만으로 동작한다. 프로그램이 동작하는 흐름에서 상태가 변화되지 않으면 함수 호출시 각각 상호 간섭없이 배타적으로 실행되므로 대규모 병렬처리가 쉽고 부작용도 거의 없다.(쓰레드 별로 특정 값을 참조하기 위해 락을 걸거나 대기할 필요가 없기 때문이다.)
    - swift 에서는 함수를 일급 객체로 취급한다. 이것은 함수를 호출하고, 전달하고, 반환하는 등의 동작만으로도 프로그램을 구현할 수 있다는 의미이다. (함수객체란 '맵을 적용할 수 있는 컨테이너 타입’이라고 말할 수 있다. Array, Dictionary, Set 등등 swift 의 많은 컬렉션 타입이 함수객체이다. 함수객체는 포장된 값에 함수를 적용할 수 있다. 그래서 모나드도 컨텍스트에 포장된 값을 처리하여 컨텍스트에 포장된 값을 다시 반환하는 함수를 적용할 수 있다. swift 에는 flatmap 을 예로 들 수 있다.

       **함수객체의 특징**
       - 전달인자로 전달할 수 있다.
       - 동적 프로퍼티 할당이 가능하다.
       - 변수나 데이터 구조 안에 담을 수 있다.
       - 반환 값으로 사용할 수 있다.
       - 할당할 때 사용된 이름과 관계없이 고유한 객체로 구별할 수 있다.)
    - 하지만 swift 에서는 완벽하게 함수형 프로그래밍을 구현할 수 없는 제약이 있다. UI 와 관련된 부분들은 모두 NSObject 로부터 상속되기 때문에 어렵고, 결국 화면과 연계하려면 다양한 값들과 상태들이 뒤섞이게 되기 때문이다. 알고리즘 구현시 컬렉션에 모델을 담아두고 map, filter, reduce, flatmap 등을 연결해서 사용할 수는 있겠지만 순수 함수로만 동작할 수 있는 범위는 그정도 선에서 그친다.
* * *


3. #### 제네릭
    - 타입에 매칭되지 않고 유연하게 코드를 작성할 수 있음
    - 코드의 중복을 줄일 수 있으며 깔끔하고 추상적인 표현이 가능함  
* * *


4. #### 옵셔널
    - 단어 뜻 그대로 ‘선택적인’, 즉 값이 ‘있을 수도, 없을 수도 있음’(모나드는 특정한 상태로 값을 포장하는 것에서 출발한다. 스위프트에서는 이를 옵셔널이라는 형태로 구현했는데 값이 있을지 없을지 모르는 상태 속에 포장하는 것이다.)
    - 문서를 확인하지 않아도 문법적 표현만 보더라도 의미를 충분히 표현할 수 있고, 옵셔널과 옵셔널이 아닌 값은 철저히 다른 타입으로 인식하기 때문에 컴파일을 할 때 바로 오류를 걸러낼 수 있다.
    - 값을 뽑을 때 암묵적 값 반환(?), 명시적 값 반환(!)
    - 선언시엔 ! 를 사용해서 해당 프로퍼티는 nil 일 수가 없음을 명시적으로 선언할 수 있으나 가급적 사용하지 않는게 좋다.
    - if let/var, guard let/var, flatmap 을 사용해서 값을 뽑아올 수 있다.
    - items.popLast()?.owner?.isCitizen 에서처럼 암묵적 값 반환을 이용한 옵셔널 체이닝을 사용할 수 있다. 어디에서든 nil 이 반환된다면 그 즉시 체이닝을 벗어나 nil 이 반환된다.
    - 그렇다면 as?, as!, is?, is!, try?, try! 도 옵셔널? No! 단순히 문법적으로만 ?, ! 를 채용한 것.
* * *

5. #### enum
    - associatedType 을 사용하여 모델링하기에 좋다. ex) 테이블 또는 컬렉션 뷰의 row 와 매칭되는 연관값으로 동적인 화면을 구성하도록 할 수 있다.



## 단점
1. String 이 Collection 이라 substring 이 불편(swift4 에서 NSRange 를 사용할 수 있다고 해도, 
* * *
2. 문자열의 중간 위치를 substring 하려면 여전히 불편함). c style for 문으로는 쉽게 표현할 수 있으나 for-in 문으로는 불편한 부분이 존재함
* * *
3. 스위프트는 아직 바이너리 안정성이 확보되어 있지 않다. abi(application binary interface)
 > 컴파일해서 실제로 튀어나온 바이너리가 스위프트 버전간 호환이 안된다. -> swift3 에서 컴파일된 바이너리를 swift4 에서는 사용 불가.
 > objc 프레임웤들은 잘 동작하지만 swift 프레임웤은 버전이 조금만 바뀌어도 서로 호환되지 않는다.
 > cocoapod, kartago 써드파티 라이브러리를 관리해주는 툴 필수
 > cocoapod 는 빌드 시간이 오래걸리지만 라이브러리 안정성을 확보할 수 있다.
애플은 작은 런타임을 바이너리에 같이 말아 넣었다. 모든 프로그램에 넣었다.
알라모파이어(네트워킹 오픈소스. 준표준이라할정도로 많이 사용된다.)
만약 써드파티가 지원이 늦어지면 헬







protocol 은 구현체 없이 요구사항만 존재
oop 는 단계가 깊어질 수록 구현체들이 많아진다. override 가 많아짐
강제적으로 추상화된

레퍼런스 타입은 참조값 추적에 비용이 많이 발생한다? -> dynamic dispatch 확인 필요

함수형 장점
객체에 map, filter, reduce, flatmap 이 구현되어 다양한 로직을 꾸밀 수있다.







* * * 
* * *


What features of Swift do you like or dislike? Why?
===================================================

고참 개발자라 함은 무릇 가장 최신 버전의 swift 에 대해 잘 파악하고 있어야 합니다.(이전 버전과의 차이점도 알고 있다면 짱짱맨 😀)
괜찮은 회사들은 개발자가 swift 의 강한 타입 제약, 언어의 함수형 프로그래밍 특징 그리고 마음에 드는 것과 그렇지 않은 것에 대해 토론할 수 있을정도의 역량을 갖추고 있길 기대합니다. 애플 개발자 사이트를 방문해 보신 분들이라면 참고할만한 문서의 양을 봐서 아시겠지만 그 양이 정말 방대하죠... 그렇기 때문에 모든 것을 다 알고 있다는 것은 사실 불가능에 가깝다고 생각합니다. 그렇기 때문에 swift 모든 버전 전반적으로 통용되고 최신 버전에서 개선된 특징 정도는 필수로 이해하고 있어야 합니다. 예를 들자면 프로토콜, 옵셔널, 제네릭, 참조 vs. 값 타입 등등
그리고 개발자 본인이 생각하기에 불편해서 개선이 필요하다고 생각하는 부분도 이야기 할 수 있어야 하죠.
네 그렇습니다... 보통 일이 아니죠. 하지만 고참 개발자의 길이란 그런 것이겠죠 😣
* * *

## 장점
1. #### 프로토콜(Protocol)
    - java, obj-c 를 접해보신 분들이라면 interface 를 사용해서 개발해 보셨을 겁니다. swift 의 프로토콜은 그와 유사한 개념입니다. 특정 역할을 수행하기 위해 메서드, 프로퍼티 및 기타 요구사항 등을 정의만 합니다. 실제 구현은 해당 프로토콜을 준수하는 구현체로 위임하기 때문이죠. 이제부터 다른 언어들과의 차이점이 생기는데요. swift 프로토콜의 초기구현을 지원합니다. 이게 무슨말이냐~ 하면
    
    ``` swift
	protocol Popable {
    	associatedtype Element
    	var elements: [Element] {get set}
    	mutating func append(_ el: Element)
    	mutating func pop() -> Element?
	}

	extension Popable {
    	mutating func append(_ el: Element) {
        	elements.append(el)
    	}
    
    	mutating func pop() -> Element? {
        	return elements.popLast()
    	}
	}

	struct Stack: Popable {
    	typealias Element = Int
    	var elements = [Element]()
	}
    ```

    - 위와 같이 Popable 을 선언하고 해당 프로토콜을 구현체 없이 확장함으로써 초기구현을 할 수 있습니다. 그러면 실제로 Popable 을 채택하여 준수하는 Stack 이라는 값 타입은 Popable 의 요구사항인 `append(_:)`, `pop()` 을 구현하지 않고 그냥 사용만 하면 되는거죠. 뭐 별거 없죠? 하지만 다른 언어와의 이런 차이점이 swift 의 특징인 프로토콜 지향 프로그래밍이 가능하도록 해주는 근간입니다.
    다른 언어에서는 무기명 타입으로 원시타입이라 불리는 Int, Double, String, Bool 등이 swift 에서는 기명 타입인 값 타입으로 구현되어 있기 때문에 초기구현을 사용하여 해당 타입에 기능을 추가할 수도 있습니다. 아래처럼 말이죠.
    
    ``` swift
    extension Int {
    	func factorial() -> Int {
    		var n = self
    		var result = 1
    		while n > 0 {
    			result *= n
    			n -= 1
    		}
    		return result
    	}
    }
    let factorialOfFour = 4.factorial()
    ```

    - 좀 근사하지 않나요? 위의 확장을 추가하면 모든 Int 타입은 자기 자신의 factorial 을 구할 수 있습니다 😉 (단 Int 에 저장할 수 있는 값의 한계때문에 20 보다 큰 정수에 대한 factorial 은 계산할 수 없습니다 😑)
    
    - oop 에서는 슈퍼 클래스가 하위 클래스들이 가져야할 기본적인 요구사항을 구현하고 하위 클래스들이 각자의 목적에 따라 추가 요구사항을 구현하는 방식으로 설계됩니다. 그래서 하위 클래스들은 초기화시 무조건 슈퍼 클래스의 생성자를 호출해야하고 이로 인해 일관된 초기화를 제공하지요. 그렇다보니 계층이 깊어지면 조금만 부주의해도 슈퍼 클래스가 요구하는 적절한 초기화 설정을 보장하지 못하고 낭패를 보는 상황을 맞이할 수도 있습니다. 하지만 pop 에서는 각각의 프로토콜은 기능을 위주로 모듈화하여 해당 프로토콜을 채택하는 타입으로 하여금 해당 기능의 기능을 구현하도록 강제합니다. 그렇기 때문에 계층과 상관없이 간결하게 해당 기능을 충족시킬 수 있습니다.(초기 구현을 해놓는다면 단순하게 채택만 하더라도 해당 기능을 사용할 수 있게 되는거죠 🤩)

    - oop 에서는 하위 클래스들은 단 하나의 슈퍼 클래스만 상속받을 수 있다보니 슈퍼 클래스가 pop 에 비해 비대해지고 불필요한 기능들도 많이 가지게 됩니다. 하지만 pop 에서는 여러개의 프로토콜을 동시에 채택할 수 있기 때문에 코드의 재사용성이 높아지고 기능들의 모듈화가 명확해집니다.
    - 제네릭과 함께 사용한다면 단일 타입이 아닌 어떠한 타입에도 대응 가능한 유연한 코드의 작성이 가능해집니다. 그렇다보니 간결하고 추상적인 표현이 가능해집니다.

2. 제네릭
    - 위에서도 잠시 설명했지만 제네릭은 특정 타입에 종속되지 않고 유연한 코드를 작성할 수 있게 해줍니다. 여러 타입에 대응할 수 있기 때문에 코드의 중복을 줄일 수 있으며 추상적인 표현이 가능합니다.

    ``` swift
	protocol Popable {
    	associatedtype Element
    	var elements: [Element] {get set}
    	mutating func append(_ el: Element)
    	mutating func pop() -> Element?
	}

	struct Stack<T>: Popable {
    	var elements = [T]()
    
    	func printSelf() {
        	for item in elements {
            	print("elements = \(item)")
        	}
   		}

    	subscript(_ index: Int) -> T? {
        	if index < elements.count {
            	return elements[index]
        	}
        	return nil
    	}
	}

	extension Stack: Sequence {
    	func makeIterator() -> AnyIterator<T> {
        	return AnyIterator(IndexingIterator(_elements: self.elements))
    	}
	}

	var intStack = Stack<Int>()
	intStack.append(1)
	intStack.append(7)
	intStack.printSelf() // 1, 7
	print("pop: \(intStack.pop()!)") // 7
	intStack.printSelf() // 1

	var stringStack = Stack<String>()
	stringStack.append("a")
	stringStack.append("b")
	stringStack.printSelf() // a, b
	print("pop: \(stringStack.pop()!)") // b
	stringStack.printSelf() // a
	```

	- 프로토콜에서 사용한 샘플에 제네릭을 추가해보면 이런식으로 됩니다. 제네릭을 사용하지 않았다면 IntStack: Popable, StringStack: Popable 이렇게 만들어야 했겠지만 제네릭을 이용해 하나의 스트럭트로 해결했습니다. 당연게도 동작도 동일하게 잘 합니다 😀

3. 옵셔널
    - 단어의 뜻에서 나타나듯 '상태가 있을 수도, 없을 수도 있는' 상태를 감싸는 컨테이너 또는 컨텍스트라고 할 수 있습니다. 옵셔널은 모나드(Monad)의 개념을 차용한 것입니다. 
    - 변수 선언시 '?' 를 사용하면 해당 변수는 값이 없을 수도 있다는 의미이고, '!' 를 사용하면 변수는 항상 값을 가진다는 의미입니다. 하지만 선언시 '!' 는 무슨일이 있어도 값이 들어있다고 100% 확신하는 경우에도 가급적 사용하지 않는것이 정신건강에 이롭습니다.
    - 옵셔널인 값과 아닌 값은 엄격하게 다른 타입으로 인식하기 때문에 컴파일러가 에러를 발생시킵니다. 덕분에 신경쓰지 않아도 자연스럽게 오류를 잡을 수 있어요. 하지만 컴파일러 에러도 발생하지 않도록 수련이 되어 있어야 고참 개발자라 할 수 있겠죠?
    - 값 반환시에는 '!' 를 사용해서 강제로 값을 뽑아올 수 있습니다. 하지만 위에서 언급한 것처럼 사용하지 않는 것이 좋습니다. run time 에 무슨 일이 발생할지 모르기 때문이죠.
    - 대신 옵셔널 체이닝을 통해 값이 있을지 없을지 모르는 경우에도 변수의 값 조회, 메서드의 호출을 연쇄적으로 할 수 있게 해줍니다.

    ``` swift
    let optionalValue = OptionalValue("ListType")
    if let element = optionalValue.value?.elements?.popLast() {
        print(element.rawValue)
    }
    ```

    - 위의 샘플에서처럼 optionalValue 의 value 가 옵셔널이고, 그 안에 있는 프로퍼티도 배열의 옵셔널인 경우 연쇄적으로 value 를 조회하고, elements 를 조회하고, popLast() 를 호출할 수 있다. nil 이 반환될 수 있음을 전제로 조회/호출하기 때문에 어딘가에서 nil 이 반환된다면 해당 옵셔널 체인은 nil 을 반환하게 되고 if 문을 벗어납니다. 그렇지 않고 성공적으로 popLast() 가 호출되어 element 에 할당되게 되면 if 문 안에서는 옵셔널이 벗겨진 채로 element 를 사용할 수 있습니다. 그리고 이런 과정을 if let binding 이라고 부릅니다. 만약 바인딩한 값이 변경될 수 있다면 if let 대신 if var 를 사용할 수 있습니다. if let/var 와 유사한 문법을 가지는 guard let/var 도 있습니다.(guard 문은 빠른 탈출이라고도 부릅니다. 그 이유는 함수 내에서 guard 문이 사용되고 만약 실패시 해당 함수를 그대로 return 하기 때문입니다. 아래의 코드처럼 말이죠.)

    ``` swift
    func foo() {
        guard let element = optionalValue.value?.elements?.popLast() else {
            return
        }
        print(element.rawValue)
        ...
        // do something
    }
    
    ```

    - 그리고 옵셔널은 enum 타입이라 case 로 some(<T>), none 을 가집니다. 그렇기 때문에 당연히 switch-case 문에서 패턴 매칭을 통해 값을 추출할 수도 있습니다.
    - 이외에도 flatmap 을 사용해 값을 뽑아올 수도 있습니다. 옵셔널의 flatmap 은 값을 확인하여 nil 이 아닌 경우에 값을 추출하여 transform 클로져의 반환값으로 전달하는 함수입니다. 옵셔널 변수 하나에 사용하기 보다는 주로 Sequence 를 준수하는 타입에서 유용하게 사용되는데 사용법은 아래와 같습니다.(각 타입별 flatmap, map 메서드는 api 를 확인해보세요~ )

    ``` swift
    let words = ["123", "eight", "-10", "3.14"]
    print(words) // ["123", "eight", "-10", "3.14"]
    // map 을 사용하면 transform 함수에서 반환하는 타입을 원소로 하는 배열을 반환합니다.
    let numbers = words.map{ Int.init($0) }
    print(numbers) // [Optional(123), nil, Optional(-10), nil]
    // filter 를 사용하면 transform 함수에서 반환하는 Bool 값이 true 인 경우, 해당 원소들만 포함하는 배열을 반환합니다.
    let filteredNumbers = numbers.filter{ $0 != nil }
    print(filteredNumbers) // [Optional(123), Optional(-10)]
    // 다시 한 번 map 을 사용해 옵셔널에서 값을 추출 후 배열을 반환합니다.
    let mappedNumbers = filteredNumbers.map{ $0! }
    print(mappedNumbers) // [123, -10]
    
    // flatMap 을 사용하면 위의 과정이 아래와 같이 한 번에 해결됩니다.
    // Int.int(:)? 에서 실패한 경우 nil 이 반환되면 해당 원소는 포함하지 않고, 변환된 값이 nil 이 아닌 경우, 옵셔널에서 값을 추출하여 해당 값을 포함한 배열을 반환합니다.
    let flatmappedNumbers = words.flatMap{ Int.init($0) }
    print(flatmappedNumbers) // [123, -10]
    ```


4. 함수형 프로그래밍



([swift 에서의 함수형 프로그래밍을 나름 이해할 수 있을만큼 해석한 링크](https://academy.realm.io/kr/posts/tryswift-rob-napier-swift-legacy-functional-programming/))


* * *	
## 단점





















