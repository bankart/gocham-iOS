How is memory management handled on iOS?
========================================
요즘의 애플리케이션들은 메모리 관리가 매우 중요합니다. 특히 iOS 앱은 메모리와 다른 하드웨어 및 시스템의 제약이 있어서 더욱 그러하죠. 이런 이유로  여러가지 유형으로 묻는 질문 중 하나입니다. ARC, MRC, Reference Type, Value Type 등이 있습니다. 
* * *

## ARC
- 스위프트의 Auto Reference Count 는 Objective-C 의 그것과 같은 컨셉으로 동작합니다. 

- ARC 는 참조 타입의 인스턴스가 메모리(heap 또는 stack)에 생성된 순간부터 해당 인스턴스에 대한 강한 참조를 추적하여, 해당 인스턴스가 변수/상수/프로퍼티에 할당되거나 해제될때 카운트를 증가시키거나 감소시킵니다. 해당 인스턴스의 레퍼런스 카운트가 0 으로 떨어져서 더 이상 해당 인스턴스에 대한 참조가 없다고 판단될 때 메모리에서 해제됩니다. 

- ARC 는 값 타입에 대해서는 레퍼런스 카운트를 증가시키거나 감소시키지 않습니다. 값 타입의 인스턴스는 변수/상수/프로퍼티에 할당될 때 복사본이 전달되기 때문입니다.

- 강한 참조 사이클이 생성되면 해당 사이클에 들어 온 인스턴스들은 메모리가 해제되지 않아 메모리 leak 이 발생합니다. 예를 들어 아래의 코드는 사람이 배우자를 만나 연예를 하고 결혼하여 아이를 낳는 일생을 축약한 것인데요 덜덜덜 어쨌든 결혼을 하면 서로 속박하면서 절대로 떨어지지 않게 됩니다. 뭐 어떻게 보면 집착이라고도 할 수 있겠죠... combine(::) 함수를 보면 combine 성공시 서로를 강한 참조 사이클로 묶어 버립니다. 덕분에 해당 Human 구현체의 인스턴스들은 메모리에서 해제되지 않는 불상사가 생기게 됩니다. 실제로 문제가 되는것을 눈으로 확인할 수 있는데요. 앱을 실행한 후 좌측 네비게이터의 디버그 세션에서 디버그 메모리 그래프 버튼을 누르면 아주 깔끔하게 메모리 leak 이 발생한 것을 확인할 수 있습니다.

![디버그 메모리 버튼](./DebugMemoryGraphButton.jpg)

``` swift
protocol Human {
    // 생식 활동은 Human + Human = Human 이라고 정의하겠습니다.
    typealias ReproductiveActivity = (Human, Human) -> Human
    var activity: ReproductiveActivity {get set}
    // 기본적으로 이름을 가지고
    var name: String {get set}
    // 배우자끼리 서로 붙여줄꺼예요. 물론 없을 수도 있겠지만...
    var attatched: Human? {get set}
    // 배우자가 마음에 안들면 튕길 수도 있습니다.
    var resistanceCount: Int {get set}
    // 결합을 시도할 수 있습니다. 결합의 성공/실패 및 연예에 대한 간절함이 얼마나 높아졌는지 튜플로 반환합니다.
    // 튕김력이 낮아질 수록 연예에 대한 간절함이 높아진다고 정의하겠습니다.
    mutating func combine(_ human: Human) -> (Bool, Int)
}
extension Human {
    mutating func combine(_ human: Human) -> (Bool, Int) {
        var human = human
        // 배우자의 방어막이 없어져야 결합에 성공할 수 있습니다.
        guard human.resistanceCount <= 0 else {
            if human.resistanceCount > 0 {
                human.resistanceCount -= 1
            }
            if resistanceCount > 0 {
                resistanceCount -= 1
            }
            print("\(self).resistanceCount: \(resistanceCount)")
            print("\(human).resistanceCount: \(human.resistanceCount)")
            return (false, human.resistanceCount)
        }
        // 방어막이 없어지면 그제서야 배우자로서 서로 뗄레야 뗄 수 없는 굴레에 들어서게 됩니다.
        human.attatched = self
        attatched = human
        print("\(#function) success")
        return (true, human.resistanceCount)
    }
    
    // 결합에 성공하면 생식활동을 하여 자식을 낳을 수 있습니다.
    func result() -> Human? {
        guard attatched != nil else { return nil }
        return activity(self, attatched!)
    }
}

class Male: Human {
    // 일단 남자라면 연예에 대한 간절함이 항상 있죠
    var resistanceCount: Int = 0
    var name: String
    var attatched: Human?
    var activity: ReproductiveActivity = {
        // 명리학이 반영된 남녀성비 계산입니다 ㅡ,.ㅡ;;;;
        return (($0.name.count/2 + $1.attatched!.name.count) % 2 == 0) ? 
                Female(name:"baby girl") : 
                Male(name:"baby boy")
    }
    
    init(name: String) {
        print("Male is appear")
        self.name = name
    }
    
    deinit {
        print("Male is gone")
    }
}

class Female: Human {
    // 여자는 좀 튕길 줄 압니다.
    var resistanceCount: Int = 2
    var name: String
    var attatched: Human?
    var activity: ReproductiveActivity = {
        // 여기도 명리학이 반영된 남녀성비 계산입니다.....
        return (($0.name.count + $1.attatched!.name.count/2) % 2 == 1) ? 
                Female(name:"baby girl") : 
                Male(name:"baby boy")
    }
    init(name: String) {
        print("Female is appear")
        self.name = name
    }
    
    deinit {
        print("Female is gone")
    }
}

func testHuman() {
    // 존 말코비치와 그의 부인 글렌 헤들리님을 모델 삼아 만들어 봤습니다.
    var malkovich: Human? = Male(name: "malkovich")
    var headly: Human? = Female(name: "headly")
    
    var resultOfCourship: Human?
    // 열 번 찍어 안넘어 가는 나무 없다는 독한 마음으로 달려갈 준비를 합니다.
    func courtshipActivity(male: Human, female: Human) {
        print("[\(#function)]")
        var male = male
        if male.combine(female).0 == true {
            print("here we go")
            // 간단한 테스트이기도 하고 구애의 결과물이 combine 이후에 나오는게 자연의 섭리에 맞는거기도 하고...
            resultOfCourship = male.result()
            return
        } else {
            print("recursive call")
            courtshipActivity(male: male, female: female)
        }
    }
    
    // 레디~ 고!
    courtshipActivity(male: malkovich!, female: headly!)
    print(resultOfCourship!.name)
    // 이렇게 출산 후 생애를 마감했습니다.
    // 하루살이도 아닌데 이름을 빌려주신 두 분께 미안한 마음이 드네요.
    // (참고로 글렌 헤들리님은 작고하셨습니다...)
    malkovich = nil
    headly = nil
}

```

![메모리 leak 발생 화면](./DebugMemoryGraph.png)

- 이런 강한 참조를 해결하는 방법은 2가지가 있습니다. attatched 프로퍼티를 약한 참조인 `weak var attatched: Human?` 으로 변경해야 하거나, 미소유 참조인 `unowned var attatched: Human` 으로 변경하면 됩니다. 우선 weak 는 레퍼런스 카운팅을 하지 않겠다는 뜻이고, 해당 프로퍼티에 할당된 인스턴스의 레퍼런스 카운트가 0 으로 떨어지면 자동으로 nil 처리되기 때문에 var 이어야 하고 또한 옵셔널이어야 합니다. unowned 도 레퍼런스 카운팅을 하지 않겠다는 것은 같지만 weak 와 반대로 절대로 옵셔널이면 안됩니다. 대신 var/let 어떤 식으로 선언해도 상관이 없습니다. 위의 예제에서는 weak 가 적당하겠네요. 만약 Human 에 parent 라는 프로퍼티를 추가한다면 그때는 unowned 를 쓰면 될것 같습니다.(변수/상수/프로퍼티 할당시 기본은 강한 참조 입니다.)

- 이 외에도 강한 참조 사이클은 참조 타입인 클로저에서도 발생할 수 있습니다. 클로저가 참조 타입의 프로퍼티인 경우 해당 클로저 안에서 인스턴스를 강한 참조하기 때문인데요. 이를 방지하기 위해 클로저에는 캡쳐 리스트라는 것을 제공하여 참조 타입을 결정하는 규칙을 적용시킬 수 있습니다.

``` swift
var fullName: () -> String = {
    // 이렇게 self 를 강하게 참조하면 그대로 강한 참조 사이클에 빠집니다.
    return self.firstName + " "+ self.lastName
}

// 대신 이렇게 하면 self 를 강한 참조가 아닌 미소유 참조로 할 수 있습니다.
var fullName: () -> String = { [unowned self] in
    return self.firstName + " "+ self.lastName
}

```









